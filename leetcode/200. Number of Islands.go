package leetcode

import (
	"log"
	"strconv"
)

func numIslands(grid [][]byte) int {
	islandCount := 0

	for row := 0; row < len(grid); row++ {
		for col := 0; col < len(grid[row]); col++ {
			if grid[row][col] == '1' {
				islandCount++
				// dfs(grid, row, col)
				bfs(grid, row, col)
			}
		}
	}

	return islandCount
}

func dfs(grid [][]byte, row, col int) {
	if row < 0 || row >= len(grid) ||
		col < 0 || col >= len(grid[row]) ||
		grid[row][col] != '1' {
		return
	}

	grid[row][col] = '2'

	dfs(grid, row+1, col)
	dfs(grid, row-1, col)
	dfs(grid, row, col+1)
	dfs(grid, row, col-1)
}

func bfs(grid [][]byte, row, col int) {
	queue := [][2]int{}
	offsets := [4][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
	queue = append(queue, [2]int{row, col})
	grid[row][col] = '2'

	for len(queue) > 0 {
		curr := queue[0]
		queue = queue[1:]

		for _, offset := range offsets {
			nextRow := curr[0] + offset[0]
			nextCol := curr[1] + offset[1]

			if nextRow < 0 || nextRow >= len(grid) ||
				nextCol < 0 || nextCol >= len(grid[row]) {
				continue
			}

			if grid[nextRow][nextCol] == '1' {
				queue = append(queue, [2]int{nextRow, nextCol})
				grid[nextRow][nextCol] = '2'
			}
		}
	}
}

type Vertice struct {
	id   string
	x, y int
}

func newVertice(x, y int) Vertice {
	return Vertice{
		x:  x,
		y:  y,
		id: strconv.Itoa(x) + "-" + strconv.Itoa(y),
	}
}

func numIslands2(grid [][]byte) int {
	graph := make(map[Vertice][]Vertice)
	for x, ys := range grid {
		for y, val := range ys {
			vertice := newVertice(x, y)
			if val == '1' {
				graph[vertice] = []Vertice{}
				if y > 0 && grid[x][y-1] == '1' {
					graph[vertice] = append(graph[vertice], newVertice(x, y-1))
				}
				if y < len(ys)-1 && grid[x][y+1] == '1' {
					graph[vertice] = append(graph[vertice], newVertice(x, y+1))
				}
				if x > 0 && grid[x-1][y] == '1' {
					graph[vertice] = append(graph[vertice], newVertice(x-1, y))
				}
				if x < len(grid)-1 && grid[x+1][y] == '1' {
					graph[vertice] = append(graph[vertice], newVertice(x+1, y))
				}
			}

		}
	}

	islandCount := 0
	checked := make(map[string][]byte) // id => ischecked
	for v, _ := range graph {
		if _, ok := checked[v.id]; !ok {
			islandBuilder(graph, v, checked)
			islandCount++
		}
	}

	return islandCount
}

func islandBuilder(graph map[Vertice][]Vertice, v Vertice, checked map[string][]byte) (ids []string) {
	if _, ok := checked[v.id]; ok {
		return
	}
	checked[v.id] = []byte{}
	ids = append(ids, v.id)

	for _, e := range graph[v] {
		ids = append(ids, islandBuilder(graph, e, checked)...)
	}

	return ids
}

func TestnumIslands() {

	type Case struct {
		grid     [][]byte
		expected int
	}

	cases := []Case{
		{
			grid: [][]byte{
				{'1', '1', '1', '1', '0'},
				{'1', '1', '0', '1', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
			},
			expected: 1,
		},
		{
			grid: [][]byte{
				{'1', '1', '0', '0', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '1', '0', '0'},
				{'0', '0', '0', '1', '1'},
			},
			expected: 3,
		},
		{
			grid: [][]byte{
				{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'},
				{'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'},
				{'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'},
				{'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
				{'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			},
			expected: 3,
		},
		{
			grid: [][]byte{
				{'1', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
				{'1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '0', '1', '0'},
				{'0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '1', '0', '1', '0'},
				{'0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '1'},
				{'0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
				{'1', '0', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0', '1'},
				{'0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1'},
				{'0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0'},
				{'0', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1'},
				{'0', '0', '1', '0', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0', '0', '1', '0'},
				{'1', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '1', '0', '1', '0'},
				{'0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0', '1', '1', '0', '0'},
				{'1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1'},
				{'0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '1', '0', '0', '0'},
				{'0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'},
				{'1', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1'},
				{'1', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'},
				{'0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '0', '0'},
				{'0', '1', '0', '0', '0', '0', '1', '1', '0', '0', '1', '0', '1', '0', '0', '1', '0', '0', '1', '1'},
				{'0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', '0'},
			},
			expected: 58,
		},
	}

	for _, testcase := range cases {
		res := numIslands(testcase.grid)

		if res != testcase.expected {
			log.Panicf("FAILED. %+v Expected %+v but got %+v", testcase.grid, testcase.expected, res)
		}

		log.Printf("MATCHED. %+v result: %+v, expected: %+v\n\n", testcase.grid, res, testcase.expected)
	}
}
